# 1. 재귀함수

factorial(5)
5! = 5 * (4 * (3 * (2 * 1)))

장점
- 코드표현이 간단해짐
단점
- 성능 이슈가 존재 가능
- 값이 커지면 스택에 메모리 공간에 쌓임
- 콜 스택이 많이 쌓이면 터질 수 있음.

## 1.1. 재귀함수 작성 시 유의사항

- 탈출 조건 명시 필요
```java
private static int factorial(int n) {
		//탈출조건!
		if ( n ==1) {
			return 1;
		}
		//5 입력 =>4*3*2*1
		//4 입력 =>3*2*1
		//3 입력 =>2*1
		//
		return n * factorial(n-1);
	}
```

꼬리 재귀 최적화(tail recursion optimization)

## 1.2. 피보나치 문제

1 1 2 3 5 ...

- n번째 항(n>2, n은 3 이상)은 n-1 번째 항과 n-2번째 항의 합

A1 = 1
A2 = 1
an = A(n-1) + A(n-2)

# 2. quicksort

- 추가적인 메모리 필요 없음
- 연산(소팅) 속도 빠름

## 2.1. 알고리즘

pivot : 5
5 3 8 4 9 1 6 2 7

l(작은 값) : 3 4 1 2 
g(큰 값) : 8 9 6 7